package handel

import (
	"errors"
	"fmt"
	"sync"
	"time"
)

// Handel is the principal struct that performs the large scale multi-signature
// aggregation protocol. Handel is thread-safe.
type Handel struct {
	sync.Mutex
	// Config holding parameters to Handel
	c *Config
	// Network enabling external communication with other Handel nodes
	net Network
	// Registry holding access to all Handel node's identities
	reg Registry
	// constructor to unmarshal signatures + aggregate pub keys
	cons Constructor
	// public identity of this Handel node
	id Identity
	// Message that is being signed during the Handel protocol
	msg []byte
	// signature over the message
	sig Signature
	// partitions the set of nodes at different levels
	part Partitioner
	// signature store with different merging/caching strategy
	store signatureStore
	// processing of signature - verification strategy
	proc signatureProcessing
	// all actors registered that acts on a new signature
	actors []actor
	// completed levels, i.e. full signatures at each of these levels
	completed []byte
	// highest level attained by this handel node so far
	currLevel byte
	// maximum  level attainable ever for this set of nodes
	maxLevel byte
	// best final signature,i.e. at the last level, seen so far
	best *MultiSignature
	// channel to exposes multi-signatures to the user
	out chan MultiSignature
	// indicating whether handel is finished or not
	done bool
	// constant threshold of contributions required in a ms to be considered
	// valid
	threshold int
	// ticker for the periodic update
	ticker *time.Ticker
}

// NewHandel returns a Handle interface that uses the given network and
// registry. The identity is the public identity of this Handel's node. The
// constructor defines over which curves / signature scheme Handel runs. The
// message is the message to "multi-sign" by Handel.  The first config in the
// slice is taken if not nil. Otherwise, the default config generated by
// DefaultConfig() is used.
func NewHandel(n Network, r Registry, id Identity, c Constructor,
	msg []byte, s Signature, conf ...*Config) *Handel {

	var config *Config
	if len(conf) > 0 && conf[0] != nil {
		config = mergeWithDefault(conf[0], r.Size())
	} else {
		config = DefaultConfig(r.Size())
	}
	h := &Handel{
		c:        config,
		net:      n,
		reg:      r,
		part:     config.NewPartitioner(id.ID(), r),
		id:       id,
		cons:     c,
		msg:      msg,
		sig:      s,
		maxLevel: byte(log2(r.Size())),
		out:      make(chan MultiSignature, 100),
		ticker:	  time.NewTicker(config.UpdatePeriod),
	}
	h.actors = []actor{
		actorFunc(h.checkCompletedLevel),
		actorFunc(h.checkFinalSignature),
	}

	h.threshold = h.c.ContributionsThreshold(h.reg.Size())
	h.store = newReplaceStore(h.part, h.c.NewBitSet)
	firstBs := h.c.NewBitSet(1)
	firstBs.Set(0, true)
	h.store.Store(0, &MultiSignature{BitSet: firstBs, Signature: s})
	h.proc = newFifoProcessing(h.store, h.part, c, msg)
	h.net.RegisterListener(h)
	return h
}

// NewPacket implements the Listener interface for the network.
// it parses the packet and sends it to processing if the packet is properly
// formatted.
func (h *Handel) NewPacket(p *Packet) {
	h.Lock()
	defer h.Unlock()
	if h.done {
		return
	}
	ms, err := h.parsePacket(p)
	if err != nil {
		h.logf("invalid packet: %s", err)
		return
	}

	// sends it to processing
	h.logf("received packet from %d for level %d: %s", p.Origin, p.Level, ms.String())
	h.proc.Incoming() <- sigPair{origin: p.Origin, level: p.Level, ms: ms}
}

// Start the Handel protocol by sending signatures to peers in the first level,
// and by starting relevant sub routines.
func (h *Handel) Start() {
	h.Lock()
	defer h.Unlock()
	go h.proc.Start()
	go h.rangeOnVerified()
	h.startNextLevel()
}

// Stop the Handel protocol and all sub routines
func (h *Handel) Stop() {
	h.Lock()
	defer h.Unlock()
	h.proc.Stop()
	h.done = true
	close(h.out)
}


func (h *Handel) periodicUpdate() {
	h.Lock()
	defer h.Unlock()

}

// FinalSignatures returns the channel over which final multi-signatures
// are sent over. These multi-signatures contain at least a threshold of
// contributions, as defined in the config.
func (h *Handel) FinalSignatures() chan MultiSignature {
	return h.out
}

// startNextLevel increase the currLevel counter and sends its best
// highest-level signature it has to nodes at the new currLevel.
// method is NOT thread-safe.
func (h *Handel) startNextLevel() {
	if h.currLevel >= h.maxLevel {
		// protocol is finished
		h.logf("protocol finished at level %d", h.currLevel)
		return
	}
	//h.findNextLevel()
	h.sendBestUpTo(int(h.currLevel))
	// increase the max level we are at
	h.currLevel++
	h.logf("Passing to a new level %d -> %d", h.currLevel-1, h.currLevel)
}

// rangeOnVerified continuously listens on the output channel of the signature
// processing routine for verified signatures. Each verified signatures is
// passed down to all registered actors. Each handler is called in a thread safe
// manner, global lock is held during the call to actors.
func (h *Handel) rangeOnVerified() {
	for v := range h.proc.Verified() {
		h.logf("new verified signature received -> %s", v.String())
		h.store.Store(v.level, v.ms)
		h.Lock()
		for _, actor := range h.actors {
			actor.OnVerifiedSignature(&v)
		}
		h.Unlock()
	}
}

// actor is an interface that takes a new verified signature and acts on it
// according to its own rule. It can be checking if it passes to a next level,
// checking if the protocol is finished, checking if a signature completes
// higher levels so it should send it out to other peers, etc. The store is
// guaranteed to have a multisignature present at the level indicated in the
// verifiedSig. Each handler is called in a thread safe manner, global lock is
// held during the call to actors.
type actor interface {
	OnVerifiedSignature(s *sigPair)
}

type actorFunc func(s *sigPair)

func (a actorFunc) OnVerifiedSignature(s *sigPair) {
	a(s)
}

// checkFinalSignature STORES the newly verified signature and then checks if a
// new better final signature, i.e. a signature at the last level, has been
// generated. If so, it sends it to the output channel.
func (h *Handel) checkFinalSignature(s *sigPair) {
	sig := h.store.FullSignature()

	if sig.BitSet.Cardinality() < h.threshold {
		return
	}
	newBest := func(ms *MultiSignature) {
		if h.done {
			return
		}
		h.best = ms
		h.out <- *h.best
	}

	if h.best == nil {
		newBest(sig)
		return
	}

	newCard := sig.Cardinality()
	local := h.best.Cardinality()
	if newCard > local {
		newBest(sig)
	}
}

// checkCompletedLevel looks if the signature completes its respective level. If it
// does, handel sends it out to new peers for this level if possible.
func (h *Handel) checkCompletedLevel(s *sigPair) {
	if h.isCompleted(s.level) {
		return
	}

	// XXX IIF completed signatures for higher level then send this higher level
	// instead
	ms, ok := h.store.Best(s.level)
	if !ok {
		panic("something's wrong with the store")
	}
	fullSize, err := h.part.Size(int(s.level))
	if err != nil {
		panic("level should be verified before")
	}
	if ms.Cardinality() != fullSize {
		return
	}

	// completed level !
	h.markCompleted(s.level)

	// go to next level if we already finished this one !
	// XXX: this should be moved to a handler "checkGoToNextLevel" that checks
	// if the combined signature has enough cardinality to pass to higher levels
	if s.level == h.currLevel {
		h.startNextLevel()
		return
	}

	// Now we check from 1st level to this level if we have them all completed.
	// if it is the case, then we create the combined signature of all these
	// levels, and send that up to the next. This part is redundant only if we
	// start the new level (that's the same action being done), but we might be
	// already at a higher level with incomplete signature so this is where it's
	// important: to improve over existing levels.
	if  s.level < h.maxLevel {
		h.sendBestUpTo(int(s.level))
	}
}

// sendBestUpTo computes the best signature possible at the given level, and
// sends it out to new nodes at level at least level + 1. It may send it to
// nodes at highest level if the intermediate levels are empty (it happens if n
// is not a power of two).  This call may not send signatures if the level given
// is already at the maximum level so it's not possible to send a `Combined`
// signature anymore - this handel node can fetch its full signature already.
// lvl can be equals to zero!
func (h *Handel) sendBestUpTo(lvl int) {
	if lvl < 0 || lvl >= h.part.MaxLevel() {
		msg := fmt.Sprintf ("skip sending best -> reached maximum level %d/%d", lvl, h.part.MaxLevel())
		panic(msg)
	}

	levelToSend, err := h.findNextLevel(lvl)
	if err != nil {
		h.logf("can't sendBestUpTo: %s", err)
		return
	}

	sp := h.store.Combined(byte(levelToSend) - 1)
	if sp == nil {
		panic("THIS SHOULD NOT HAPPEN AT ALL")
	}
	if levelToSend != lvl+1 {
		h.logf("\n\n ----+++ skipping levels %d -> %d for %s ---+++\n\n", lvl, levelToSend, sp)
	}
	// just checking
	// XXX Not possible to do this check anymore since two same levels from the
	// perspective of two nodes may not have the cardinality when not using N as
	// power of two.
	/*fullSize, err := h.part.Size(levelToSend)*/
	//if err != nil {
	//panic(err)
	//}
	//if sp.BitLength() != fullSize {
	//fmt.Printf("lvl %d -> levelToSend %d, sp.BitLength() %d vs fullSize %d\n", lvl, levelToSend, sp.BitLength(), fullSize)
	//panic("THIS SHOULD NOT HAPPEN AT ALL #2")
	/*}*/
	// TODO: if no new nodes are available, maybe send to same nodes again
	// in case for full signatures ?
	newNodes, ok := h.part.PickNextAt(levelToSend, h.c.CandidateCount)
	if ok {
		//h.logf("sending complete signature for level %d (size %d) to %d new nodes", sp.level, sp.ms.BitSet.BitLength(), len(newNodes))
		h.logf("sending out complete signature of lvl %d (actual lvl %d & size %d) to %v", lvl, levelToSend, sp.BitSet.BitLength(), newNodes)
		h.sendTo(levelToSend, sp, newNodes)
	} else {
		h.logf("no new nodes for completed level %d", levelToSend)
	}
}

// findNextLevel loops from lvl+1 to max level to find a level which is not
// empty and returns that level
func (h *Handel) findNextLevel(lvl int) (int, error) {
	for l := lvl + 1; lvl <= h.part.MaxLevel(); l++ {
		_, err := h.part.Size(l)
		if err != nil {
			if err == errEmptyLevel {
				continue
			}
			return 0, err
		}
		return l, nil
	}
	return 0, errors.New("no non-empty level found")
}

func (h *Handel) sendTo(lvl int, ms *MultiSignature, ids []Identity) {
	buff, err := ms.MarshalBinary()
	if err != nil {
		h.logf("error marshalling multi-signature: %s", err)
		return
	}

	packet := &Packet{
		Origin:   h.id.ID(),
		Level:    byte(lvl),
		MultiSig: buff,
	}
	h.net.Send(ids, packet)
}

// parsePacket returns the multisignature parsed from the given packet, or an
// error if the packet can't be unmarshalled, or contains erroneous data such as
// out of range level.  This method is NOT thread-safe and only meant for
// internal use.
func (h *Handel) parsePacket(p *Packet) (*MultiSignature, error) {
	if p.Origin >= int32(h.reg.Size()) {
		return nil, errors.New("packet's origin out of range")
	}

	lvl := int(p.Level)
	if lvl  < 1 || lvl > log2(h.reg.Size()) {
		msg := fmt.Sprintf("packet's level out of range, level received=%d, max=%d, nodes count=%d",
			lvl, log2(h.reg.Size()), h.reg.Size())
		return nil, errors.New(msg)
	}

	ms := new(MultiSignature)
	err := ms.Unmarshal(p.MultiSig, h.cons.Signature(), h.c.NewBitSet)
	return ms, err
}

// isCompleted returns true if the given level has already been completed, i.e.
// is in the list of completed levels.
func (h *Handel) isCompleted(level byte) bool {
	for _, l := range h.completed {
		if l == level {
			return true
		}
	}
	return false
}

func (h *Handel) markCompleted(level byte) {
	h.completed = append(h.completed, level)
}

func (h *Handel) logf(str string, args ...interface{}) {
	now := time.Now()
	timeSpent := fmt.Sprintf("%02d:%02d:%02d", now.Hour(),
		now.Minute(),
		now.Second())
	idArg := []interface{}{timeSpent, h.id.ID()}
	logf("%s: handel %d: "+str, append(idArg, args...)...)
}
