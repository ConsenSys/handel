package handel

import (
	"errors"
	"sync"
)

// Handel is the principal struct that performs the large scale multi-signature
// aggregation protocol. Handel is thread-safe.
type Handel struct {
	sync.Mutex
	// Config holding parameters to Handel
	c *Config
	// Network enabling external communication with other Handel nodes
	net Network
	// Registry holding access to all Handel node's identities
	reg Registry
	// constructor to unmarshal signatures + aggregate pub keys
	cons Constructor
	// public identity of this Handel node
	id Identity
	// Message that is being signed during the Handel protocol
	msg []byte
	// signature over the message
	sig Signature
	// partitions the set of nodes at different levels
	part partitioner
	// signature store with different merging/caching strategy
	cache signatureStore
	// channel to exposes multi-signatures to the user
	out chan MultiSignature
}

// NewHandel returns a Handle interface that uses the given network and
// registry. The identity is the public identity of this Handel's node. The
// constructor defines over which curves / signature scheme Handel runs. The
// message is the message to "multi-sign" by Handel.  The first config in the
// slice is taken if not nil. Otherwise, the default config generated by
// DefaultConfig() is used.
func NewHandel(n Network, r Registry, id Identity, c Constructor,
	msg []byte, s Signature, conf ...*Config) (*Handel, error) {
	h := &Handel{
		net:   n,
		reg:   r,
		part:  newBinTreePartition(id.ID(), r),
		id:    id,
		cons:  c,
		msg:   msg,
		sig:   s,
		cache: newReplaceStore(),
	}

	if len(conf) > 0 && conf[0] != nil {
		h.c = mergeWithDefault(conf[0], r.Size())
	} else {
		h.c = DefaultConfig(r.Size())
	}

	return h, nil
}

// NewPacket implements the Listener interface for the network.
// It returns an error in case the packet is not a properly formatted packet or
// contains erroneous data.
func (h *Handel) NewPacket(p *Packet) error {
	h.Lock()
	defer h.Unlock()

	ms, err := h.parsePacket(p)
	if err != nil {
		return err
	}
	h.processPacket(p, ms)
	return nil
}

// Start the Handel protocol
func (h *Handel) Start() {
	h.Lock()
	defer h.Unlock()
}

// parsePacket returns the multisignature parsed from the given packet, or an
// error if the packet can't be unmarshalled, or contains erroneous data such as
// an invalid signature or out of range origin. This method is NOT thread-safe
// and only meant for internal use.
func (h *Handel) parsePacket(p *Packet) (*MultiSignature, error) {
	if p.Origin >= uint32(h.reg.Size()) {
		return nil, errors.New("handel: packet's origin out of range")
	}

	if int(p.Level) > log2(h.reg.Size()) {
		return nil, errors.New("handel: packet's level out of range")
	}

	ms := new(MultiSignature)
	err := ms.Unmarshal(p.MultiSig, h.cons.Signature(), h.c.NewBitSet())
	if err != nil {
		return nil, err
	}

	return nil, nil
	//err = h.verifySignature(ms, p.Origin, p.Level)
	//return ms, err
}

// processPacket stores the signature to the cache. If it is a new
// multisignature or a "better" one, it applies the Handel logic. See Protocol
// section from the paper.
func (h *Handel) processPacket(p *Packet, ms *MultiSignature) {
	new := h.cache.Store(p.Level, ms)
	if !new {
		// nothing new to do here
		return
	}

	ms, present := h.cache.Best(p.Level)
	if !present {
		panic("something is wrong with the signature cache")
	}

	// 1.to update our peers about this new ms, and
	// 2. if threshold is reached, (re)-start the next level
	// 3. if it is complete,  ... ?
	setCount := ms.BitSet.Cardinality()
	if setCount >= h.c.ContributionsThreshold {
		// ---
	}
}
